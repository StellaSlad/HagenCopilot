question,answer,contexts,ground_truth,answer_correctness
Was ist der Unterschied zwischen Browsing und direkter Suche?," Der Unterschied zwischen Browsing und direkter Suche besteht darin, dass beim Browsing manuell auf verschiedene Seiten gesurft wird, ohne eine bestimmte Suchausgabe vorzubereiten. Dabei erfolgt meist die Auswahl ueber Links, die aus dem Wissen des Surfers oder einer Empfehlung von Suchmaschinen vorgeschlagen werden. Direkte Suche hingegen betrifft den Vorgang, in dem man eine bestimmte Frage an eine Suchmaschine stellt und diese auf relevanten Inhalten antwortet. Hierbei wird das Ergebnis nicht durch direkten Zugriff, sondern ueber ein Algorithmus berechnet, das sich auf die verwendeten Schluesselwoerter bezieht.","['Selbsttestaufgabe 3.1 Erlaeutern Sie den Unterschied zwischen einem wohlgeformten und einem gueltigen XML-Dokument'
 'Inhaltsverzeichnis 1. Einleitung 2. XSL-Transformationen 3. XQuery 4. Anhang 5. Literatur 6. Loesungen der Selbsttestaufgaben'
 'Kurs 01877  Einsendeaufgaben  zu Kurseinheit  3  - 5 -      Frage  7      https://www.freeformatter.com/xpath -tester.html'
 ""time, mark, audio, video {       margin: 0;       padding: 0;       border: 0;       font-size: 100%;       font: inherit;       vertical -align: baseline;   }    /* HTML5 display -role reset for older browsers (IE8 etc) */   article, aside, details, figcaption, figure, footer, header,  hgroup, menu, nav, section {       display: block;   }  table {      border-collapse: collapse;       border-spacing: 0;   }      /* Hier die spezifischen Styles: */   body {      font-family: 'Trebuchet MS', 'Lucida Grande', 'Lucida Sans  Unicode', 'Lucida Sans', Tahoma, sans -serif;      line-height: 1.6;       color: blue;       background -color: lightyellow;   }    .page-wrapper {       /*    Lesefluss opimieren durch Zeilenbreite begrenzen! */       max-width: 60em;       margin: 0 auto;""
 ""}      /* Hier die spezifischen Styles: */   body {      font-family: 'Trebuchet MS', 'Lucida Grande', 'Lucida Sans  Unicode', 'Lucida Sans', Tahoma, sans -serif;      line-height: 1.6;       color: blue;       background -color: lightyellow;   }    .page-wrapper {       /*    Lesefluss opimieren durch Zeilenbreite begrenzen! */       max-width: 60em;       margin: 0 auto;       padding: 5% 10%;   }        h1,""]","Browsing bezeichnet eine aktive Auseinandersetzung mit neuen Inhalten ohne ein konkretes Informationsbeduerfnis. Direkte Suche hingegen dient dazu, ein spezielles Informationsbeduerfnis zu befriedigen.",0.7323874568650779
Was sind die drei Ebenen des Dokumentenmodells?," Die drei Ebenen des Dokumentenmodells sind Inhaltsebene, Strukturebene und Formatebene. Die Inhaltsebene bezieht sich auf den rein textuellen Inhalt eines Dokuments, die Strukturebene dient der expliziten Repraesentation der Dokumentstruktur durch das Einfuegen von Markup und die Formatebene beschaeftigt sich mit der Formatierung der bereits strukturierten Inhalte.","['Inhaltsverzeichnis III    Inhaltsverzeichnis   Inhaltsverzeichnis  .................................................................................................................... III  1. Einleitung  ........................................................................................................................  4  2. Der Dokumentenbegriff ................................................................................................... 4  3. Der Modellbegriff ............................................................................................................ 5  4. Realisierung des Dokumentenmodells  .............................................................................. 5'
 'Das Modell unterstuetzt jedoch nicht nur Anwendungsfaelle des Dokumenten-managements im engeren Sinne, sondern traegt  auch Anwendungen im weite- ren Bereich des Informations - und Wissensmanag ements Rechnung. Das Modell der   strukturierten Dokumente dient somit als Werkzeug, um Texte zu gut zu verwalten-den Texten weiterzuentwickeln und die maschinelle Lesbarkeit und automatisierte  Verarbeitung zu ermoeglichen.  Dokumenten- management   Informations - und  Wissensmanagement'
 'sentation der Struktur des Dokumentes (zweite Ebene) im Sinne einer strukturellen  Repraesentation. D.  h., Autoren eines strukturierten Dokumentes editieren den ei- gentlichen Inhalt des Dokumentes und markieren die notwendigen Strukturelemen-te.  Daraufhin folgt die dritte Ebene im Modell der strukturierten Ebene, die sich auf die Formatierung der bereits strukturierten Inhalte bezieht. Das zu den Textelementen passende Format kann aus einer separaten, vom Dokument unab- haengigen und bei Bedarf auswechselbaren Formatvorlage, auch Style sheet genannt,  berechnet werden.   Das Stylesheet enthaelt  allgemeine Regeln,  wie die einzelnen Strukturelemente  zu  formatieren  sind. Durch  eine Regel kann beispielsweise festgelegt werden, dass Strukturebene des  Dokumentes   Formatebene des'
 'Der Oberbegriff zu Markierungen und eventuellen weiteren Moeglichkeiten, nicht zum Inhalt zae hlende  Zeichen in einen Text  einzustreuen, ist der Begriff Auszeichnung (engl. markup ).  Selbsttestaufgabe  1.5  Beschreiben Sie die drei Ebenen des Modells der strukturierten Dokumente, die im Kurstext genannt  werden, in eigenen  Worten.   Die erste Ebene  des Modells  der strukturierten  Dokumente  bezieht  sich auf den Inhalt  eines  Doku- ments.  Gemeint sind damit die rein textuellen Inhalte in Form von Buchstaben und Zeichen, die beim  Verarbeiten / Lesen zu  Woertern zusammengesetzt und mit Bedeutung versehen werden. (Inhaltsebe- ne)  Die zweite Ebene (Strukturebene) bezeichnet die explizite Repraesentation der Struktur des Dokuments,'
 'ments.  Gemeint sind damit die rein textuellen Inhalte in Form von Buchstaben und Zeichen, die beim  Verarbeiten / Lesen zu  Woertern zusammengesetzt und mit Bedeutung versehen werden. (Inhaltsebe- ne)  Die zweite Ebene (Strukturebene) bezeichnet die explizite Repraesentation der Struktur des Dokuments,  die ueber das  Einfuegen von z.  B. Markup realisiert wird.   Darauf aufbauend folgt die dritte Ebene im Modell der strukturierten Ebene (Formateb ene), die sich  auf die Formatierung  der bereits strukturierten Inhalte bezieht. Das zu den Textelementen passende  Format kann aus einer separaten Formatvorlage, auch Stylesheet genannt, erzeugt werden.']","Die inhaltliche Ebene, die Strukturebene und die Formatebene.",0.8914604490986049
"Erklaere das Zusammenspiel von HTML, CSS und JavaScript!"," HTML (Hypertext Markup Language) ist die Sprache fuer den Aufbau der Website. Es definiert wie die Inhalte des Dokuments aufgebaut sind und wie diese mit dem Browser darstellbar sind.  CSS (Cascading Style Sheets) dient zur Styling von HTML-Elementen. Mit CSS koennen die Aussehen von Elementen wie Farbe, Groeße, Lage usw. festgelegt werden.  JavaScript ist eine Programmiersprache, mit der interaktive und dynamische Effekte auf Websites realisiert werden koennen. Es wird verwendet, um die Webseite zu animieren, auf Benutzerinteraktion zu reagieren und zur Verarbeitung von Daten einzusetzen.  Das Zusammenspiel von HTML, CSS und JavaScript ergibt eine dynamisch interaktive Webseite mit optimalem Design und guter Lesbarkeit.","['Prof. Dr. Matthias Hemmje   01877   Dokumenten - und Wissensmanagement im Internet   Kurseinheit 2 :  Einfuehrung in HTML, CSS und JavaScript'
 '5 JavaScript  ................................ ................................ ................................ ......................  53  6 Zusammenfassung  ................................ ................................ ................................ .........  61  7 Anhang: Materialien zu HTML und CSS  ................................ ................................ ..........  62  8 Literaturverzeichnis  ................................ ................................ ................................ ........  75  9 Abbildungsverzeichnis  ................................ ................................ ................................ ... 76'
 'Anhang: Materialien zu HTML und CSS  74    f. Mit CSS -Stylesheet fo rmatiertes Dokument'
 'Inhaltsverzeichnis 1. Einleitung 2. XSL-Transformationen 3. XQuery 4. Anhang 5. Literatur 6. Loesungen der Selbsttestaufgaben'
 ""}      /* Hier die spezifischen Styles: */   body {      font-family: 'Trebuchet MS', 'Lucida Grande', 'Lucida Sans  Unicode', 'Lucida Sans', Tahoma, sans -serif;      line-height: 1.6;       color: blue;       background -color: lightyellow;   }    .page-wrapper {       /*    Lesefluss opimieren durch Zeilenbreite begrenzen! */       max-width: 60em;       margin: 0 auto;       padding: 5% 10%;   }        h1,""]","HTML, CSS und JavaScript arbeiten zusammen, um strukturierte Dokumente im Web zu erstellen. HTML ist fuer die Text- und Strukturdarstellung zustaendig, CSS fuer die Formatvorgaben und JavaScript fuer die Interaktivitaet und dynamische Manipulation der Webseite. Dieses Zusammenspiel realisiert das Prinzip der Separation of Concerns, indem es unterschiedliche Verantwortlichkeiten auf verschiedene Technologien verteilt.",0.6574792346153719
Welchen Zweck hat eine Dokumententyp-Definition?," Eine Dokumententyp-Definition (DTD oder XSD) dient zur Beschreibung einer strukturierten Datei und gibt die zulaessigen Tags, Attribute und ihre Hierarchie fest. Dies sorgt dafuer, dass die Daten in der Datei einheitlich gespeichert und verarbeitet werden koennen.","['Kurs 01877  Einsendeaufgaben  zu Kurseinheit  1  - 1 -    Kurs  01877  Informationsvisualisierung  im Internet  Einsendeaufgaben zu  Kurseinheit  1    Frage  1  Markieren  Sie die korrekten  Aussagen  zum Dokumentenbegriff       Frage  2  Welche  der folgenden  Aussagen  treffen  auf Dokumente  neuerer  Art zu?'
 'Selbsttestaufgabe 3.1 Erlaeutern Sie den Unterschied zwischen einem wohlgeformten und einem gueltigen XML-Dokument'
 '2. Der Dokumentenbegriff  Fuer statisch -passive Dokumente wurde bereits in den achtziger Jahren das Modell  der strukturierten Dokumente  entwickelt. Durch dieses Modell wird eine Untertei- lung in  textuellen Inhalt, logische Struktur und gra fisches Format moeglich. Die  Quellrepraesentation des Dokuments bezieht sich  auf den textuellen Inhalt und  logische Struktur. Gesteuert von unabhaengigen Formatvorgaben (engl. stylesheets )  laesst sich daraus das gra fische Format generieren.   Moderne Systeme zur Erstellung und Verwaltung von Dokumenten und großen Do- kumentenbestaenden profitieren vom  Modell der strukturierten Dokumente, da es  ein hohes Maß an Flexibilitaet bietet. Die logische Strukturierung unterstuetzt  Anwen-'
 'Ueberlegen Sie, ob auf die folgenden Dokumente eher der urspruengliche, der neuere oder der moderne  Dokumentenbegriff  passt oder ob es sich vielleicht gar nicht um Dokumente handelt.   • Personalausweis   • Geldschein   • Gemaelde   • Veranstaltungsplakat   • Privatbrief   • E-Mail- Nachricht   • Memo  an die Geschaeftsleitung   • Gedichtband   • Roman   • Bestellung   • Produktbeschreibung   • Fragebogen   • Nachricht  in einem  Protokoll  zum digitalen  Zahlungsverkehr  (Electronic  Banking)'
 'Inhaltsverzeichnis 1. Einleitung 2. Motivation und grundlegende Konzepte von XML 3. Die Struktur von XML-Dokumenten 4. DTD und XSD 5. Konfliktvermeidung bei XML 6. Verweise per XML 7. Anhang 8. Literatur 9. Loesung der Selbsttestaufgaben']","Eine Dokumententyp-Definition (DTD) dient dazu, die Struktur und die erlaubten Elemente eines XML-Dokuments zu definieren. Sie stellt sicher, dass das Dokument wohlgeformt und valide ist, indem sie die Regeln und das Inhaltsmodell vorgibt, an die sich das XML-Dokument halten muss.",0.7376265542419959
"Was bedeutet der Ausdruck <!ELEMENT vorlesung (titel,dozent,semester)> in einem XML-Dokument?"," 1. Die korrekte Deklaration eines Elementes lautet `<ELEMENT titel (#PCDATA)>`. 2. Mit Entity-Deklarationen koennen Entity-Referenzen definiert werden. Es gibt jedoch die Moeglichkeit, eigenen Entities definieren zu koennen. 3. Das XML-Dokument ist wie folgt: ```xml <buch verlag=""FernUniversitaet Hagen"">     <kapitel type=""na"">         <ueberschrift>Kurs 01877</ueberschrift>         <absatz>Einsendeaufgaben zu Kurseinheit 3 - 5</absatz>     </kapitel> </buch> ``` 4. Die Element- und Attribut-Deklarationen sind in einer DTD wie folgt: ```xml <!ELEMENT buch (kapitel+) > <!ATTLIST buch verlag CDATA #REQUIRED>  <!ELEMENT kapitel (ueberschrift, absatz+) > <!ATTLIST kapitel type (na | xml | java) #IMPLIED>  <!ELEMENT ueberschrift (#PCDATA)> <!ELEMENT absatz (#PCDATA)> ``` 5. Die DTD fuer das folgende XML-Dokument lautet: ```xml <!-- buch.dtd --> <!ELEMENT buch (katalog, buche*)> <!ATTLIST buch katalog_id ID #REQUIRED>  <!ELEMENT katalog (titel, buche+)> <!ATTLIST katalog katalog_name CDATA #REQUIRED>  <!ELEMENT buche (titel, herausgeber*, verlag*, preis*)> <!ATTLIST buche isbn ID #REQUIRED> <!ATTLIST buche edition CDATA #IMPLIED>  <!ELEMENT titel (#PCDATA)> <!ELEMENT herausgeber (vorname, nachname, affiliation?)> <!ELEMENT verlag (#PCDATA)> <!ELEMENT preis (#PCDATA)> <!ELEMENT vorname (#PCDATA)> <!ELEMENT nachname (#PCDATA)> <!ELEMENT affiliation (#PCDATA)> ``` 6. Der Ausdruck `<!ELEMENT vorlesung (titel,dozent,semester)>` in einem XML-Dokument bedeutet, dass das Element ""vorlesung"" aus den Kinderelementen ""titel"", ""dozent"" und ""semester"" besteht.","['<!ELEMENT  bib (book*  )>  <!ELEMENT  book  (title,  (author+  | editor+  ), publisher,  price  )>  <!ATTLIST  book  year CDATA  #REQUIRED  >  <!ELEMENT  author  (last,  first )>  <!ELEMENT  editor  (last,  first, affiliation  )>  <!ELEMENT  title (#PCDATA  )>  <!ELEMENT  last (#PCDATA  )>  <!ELEMENT  first (#PCDATA  )>  <!ELEMENT  affiliation  (#PCDATA  )>  <!ELEMENT  publisher  (#PCDATA  )>  <!ELEMENT  price  (#PCDATA  )>      Der Inhalt  dieser  Literaturdatenbank  („http://bstore1.example.com/bib.xml “) sei wie folgt:   <result>    <p>NKlabe  / La nueva  escuela</p>    <p>La  33 / La 33</p>   </result>'
 '• XML bietet  die Moeglichkeit,  nahezu  beliebige  Datenkollektionen  strukturiert  und  anwendungsunabhaengig zu speichern.       Frage  2  Welche  der folgenden  Deklarationen  eines  Elementes  ist korrekt?     • <ELEMENT  titel (#!PCDATA!)>   • <!ELEMENT  titel (#PCDATA)>   • <ELEMENT>  titel (#PCDATA)></ELEMENT>   • <!ELEMENT  titel /<ELEMENT>  (#PCDATA)>       Frage  3  Welche  der folgenden  Aussagen  ist korrekt?     • Mit Entity -Deklarationen  koennen  Entity -Referenzen  definiert  werden.   • Es werden  Entity -Referenzen  von XML – etwa  fuer die Benutzung  des Ampersand  zur  Verfuegung gestellt – diese reichen voellig aus und deswegen koennen keine eigenen  Entities definiert werden.         Frage  4  Gegeben  ist das folgende  XML-Dokument:'
 'Kurs 01877  Einsendeaufgaben  zu Kurseinheit  3  - 5 -      Frage  7      https://www.freeformatter.com/xpath -tester.html'
 'Element -Deklarationen:   <!ELEMENT  buch  > (kapitel+)  </>  <!ELEMENT  kapitel  > (ueberschrift,  absatz+)  </>  <!ELEMENT  ueberschrift  > (#PCDATA)  </>  <!ELEMENT  absatz  > (#PCDATA)  </>  Attribut -Deklarationen:   <!ATTLIST  buch  > verlag  CDATA  #REQUIRED</>   <!ATTLIST  kapitel  > type (na | xml | java)  #IMPLIED</>   Element -Deklarationen:   <!ELEMENT  buch  (kapitel+)  >  <!ELEMENT  kapitel  (ueberschrift,  absatz+)  >  <!ELEMENT  ueberschrift  (#PCDATA)  >  <!ELEMENT  absatz  (#PCDATA)  >  Attribut -Deklarationen:   <!ATTLIST  buch  verlag  CDATA  #REQUIRED>   <!ATTLIST  kapitel  type (na | xml |  java)  #IMPLIED>  Frage  5  Geben  Sie zu folgendem  XML-Dokument  die Element - und Attribut -Deklarationen  in Form  einer DTD an („buch.dtd“).'
 'Selbsttestaufgabe 3.8 Bestimmen Sie fuer alle Elemente und Attribute des folgenden XML-Dokuments, ob sie zu einem Namensraum gehoeren, und wenn ja, zu welchem. Die Elemente gehoeren alle zu einem Namensraum. Die Attribute von Elementen des ersten Buchs gehoeren zum Namensraum mit der URI http://www.kurs1873.de/buch, die Attribute von Elementen des zweiten Buchs gehoeren hingegen zu keinem Namensraum. Das Element katalog und das zugehoerige Kindelement titel gehoeren zum Namensraum mit der URI http://www.kurs1873.de/katalog. Alle anderen Elemente gehoeren zum Namensraum mit der URI http://www.kurs1873.de/buch. Dazu gehoeren weiterhin die Attribute von Elementen des ersten Buchs. Selbsttestaufgabe 3.9 Gegeben sei folgende DTD fuer ein Buch: à Kurstext']","Der Ausdruck <!ELEMENT vorlesung (titel,dozent,semester)> in einem XML-Dokument bedeutet, dass das Element 'vorlesung' aus den Kindelementen 'titel', 'dozent' und 'semester' besteht, und zwar genau in dieser Reihenfolge.",0.22084625516996634
Deklarieren Sie die Attribute eines bereits deklarierten Elements Kundenname. Es soll ein optionales Attribut Telefonnummer geben und ein verpflichtendes Attribut Kundentyp mit den moeglichen Werten Neukunde und Bestandskunde. Verwende bitte einfache Anfuehrungszeichen statt doppelten Anfuehrungszeichen und Tabs statt Zeilenumbruechen., <!ATTLIST Kundenname Telefonnummer CDATA #IMPLIED           Kundentyp (Neukunde | Bestandskunde) #REQUIRED>,"['FIXED angegeben. Dieses Attribut muss bei der Nutzung des betreffenden Elements nicht angegeben werden. Wird es aber angegeben, dann muss der dort benutzte Wert dem Standardwert entsprechen. Wert Der Standardwert wird in Anfuehrungszeichen direkt angegeben. Zudem gibt es zehn Attributtypen: 1. CDATA Dies ist der ganz allgemeine Attributtyp. Jeder Zeichentext, der die Wohlgeformtheit des Attributwertes nicht verletzt, ist erlaubt. CDATA steht fuerSelbsttestaufgabe 3.4 Definieren Sie ein DTD-Element telefonnummer, das aus den Elementen landesvorwahl , vorwahl und nummer in genau dieser Reihenfolge besteht.'
 'Attributdeklaration beginnt mit einem Kleiner- und einem Ausrufezeichen, dem Schluesselwort ATTLIST und dem Namen des Elements, fuer das Attribute definiert werden sollen. Danach folgen vor dem Groeßer-Zeichen ein oder mehrere Attribute, bestehend jeweils aus dem Attributnamen, dem Attributtyp und eventuell einem Standardwert. Ein Beispiel ist <!ATTLIST autor name CDATA #REQUIRED> Hier wird fuer das bereits deklarierte Element autor das Attribut name definiert. Der Typ des Attributwerts ist CDATA und der Standardwert ist #REQUIRED. Zunaechst gibt es vier Arten von Standardwerten: #IMPLIED Dieses Attribut ist optional. #REQUIRED  Dieses Attribut ist verpflichtend. #FIXED Wert  Der Wert dieses Attributs ist fest und wird hinter dem Schluesselwort'
 '<!ELEMENT  kapitel  (ueberschrift,  absatz+)  >  <!ELEMENT  ueberschrift  (#PCDATA)  >  <!ELEMENT  absatz  (#PCDATA)  >  Attribut -Deklarationen:   <!ATTLIST  buch  verlag  CDATA  #REQUIRED>   <!ATTLIST  kapitel  type (na | xml |  java)  #IMPLIED>  Frage  5  Geben  Sie zu folgendem  XML-Dokument  die Element - und Attribut -Deklarationen  in Form  einer DTD an („buch.dtd“).       Beachten  Sie dabei,  dass  ein Buch  mindestens  ein Kapitel  und ein Kapitel  wiederum  eine  Ueberschrift und mindestens einen Absatz besitzt.   Waehrend das Attribut verlag des Elements buch zwingend anzugeben sein soll, soll die  Angabe  des Attributs  type des Elements  kapitel optional  bleiben,  aber nicht  frei waehlbar  sein.    Welcher  der folgenden  Loesungsvorschlaege  ist richtig?'
 'dressing enthalten sein. Die Reihenfolge der Elemente ist beliebig. Deklarieren Sie die Elemente hauptzutat, zutat und dressing jeweils mit dem Inhaltsmodell #PCDATA. Die DTD lautet: <!ELEMENT rezept (((hauptzutat),((zutat)+|(dressing)))|(((dressing)|(zutat)+), (hauptzutat)))> <!ELEMENT hauptzutat (#PCDATA)> <!ELEMENT zutat (#PCDATA)> <!ELEMENT dressing (#PCDATA)> Selbsttestaufgabe 3.6 Deklarieren Sie die Attribute eines bereits deklarierten Elements Name. Es soll ein optionales Attribut Alter geben, ein Attribut Form mit festem Wert Nix und ein verpflichtendes Attribut Kundentyp mit den moeglichen Werten Gut, Schlecht, und Unbekannt. Die Attribut-Deklaration lautet <!ATTLIST Name Alter NMTOKEN #IMPLIED'
 'Hier wird fuer das bereits deklarierte Element autor das Attribut name definiert. Der Typ des Attributwerts ist CDATA und der Standardwert ist #REQUIRED. Zunaechst gibt es vier Arten von Standardwerten: #IMPLIED Dieses Attribut ist optional. #REQUIRED  Dieses Attribut ist verpflichtend. #FIXED Wert  Der Wert dieses Attributs ist fest und wird hinter dem Schluesselwort FIXED angegeben. Dieses Attribut muss bei der Nutzung des betreffenden Elements nicht angegeben werden. Wird es aber angegeben, dann muss der dort benutzte Wert dem Standardwert entsprechen. Wert Der Standardwert wird in Anfuehrungszeichen direkt angegeben. Zudem gibt es zehn Attributtypen: 1. CDATA Dies ist der ganz allgemeine Attributtyp. Jeder Zeichentext, der die']",<!ATTLIST Kundenname Telefonnummer NMTOKEN #IMPLIED	Kundentyp (Neukunde | Bestandskunde) #REQUIRED>,0.6175000800664023
Was sind die Vorteile von XSD gegenueber DTD?," XSD (XML Schema Definition) bietet gegenueber DTD (Document Type Definition) mehr Flexibilitaet und Ausdruckskraft. Hier einige Vorteile von XSD: 1. Rekursives Typvergabemechanismus: Mit diesem Mechanismus koennen unterschiedliche Typen fuer das gleiche Schema-Element definiert werden, was genauere und strengere Pruefungen ermoeglicht. 2. Validierung von XML-Dokumenten: XSDs koennen ebenfalls auf Wohlgeformtheit und Gueltigkeit geprueft werden, da sie selbst XML-Dokumente sind. 3. Inhaltsbeschraenkung: XSD ermoeglicht es, den Inhalt von Elementen und Attributen zu beschraenken, z.B. auf Zahlen, Datumsangaben oder Texte, beispielsweise mittels regulaerer Ausdruecke. 4. Komplexitaet: XSDs sind komplexer als DTDs, aber die hoehere Ausdruckskraft macht es fuer komplexe XML-Dokumente geeigneter.","['Inhaltsverzeichnis 1. Einleitung 2. Motivation und grundlegende Konzepte von XML 3. Die Struktur von XML-Dokumenten 4. DTD und XSD 5. Konfliktvermeidung bei XML 6. Verweise per XML 7. Anhang 8. Literatur 9. Loesung der Selbsttestaufgaben'
 'Definitions, XSDs) nuetzlich. Mithilfe eines rekursiven Typvergabemechanismus erreichen XSDs gegenueber DTDs eine hoehere Ausdruckskraft, sind dadurch aber auch komplexer. Dieser Mechanismus erlaubt es, fuer dasselbe Schema-Element unterschiedliche Typen zu definieren. Dadurch sind mit XSD auch genauere und strengere Pruefungen moeglich. Da XSDs selbst XML-Dokumente sind, koennen sie entsprechend auf Wohlgeformtheit und Gueltigkeit geprueft werden. XSD ist somit neben DTD eine Moeglichkeit, die Struktur von XML-Dokumenten zu beschreiben. XSD bietet auch die Moeglichkeit, den Inhalt von Elementen und Attributen zu beschraenken, z. B. auf Zahlen, Datumsangaben oder Texte, beispielsweise mittels regulaerer Ausdruecke. Die Syntax und Semantik einer DTD ist Bestandteil der XML-'
 'Inhaltsverzeichnis 1. Einleitung 2. XSL-Transformationen 3. XQuery 4. Anhang 5. Literatur 6. Loesungen der Selbsttestaufgaben'
 'Kurs 01877  Einsendeaufgaben  zu Kurseinheit  3  - 5 -      Frage  7      https://www.freeformatter.com/xpath -tester.html'
 'Selbsttestaufgabe 3.1 Erlaeutern Sie den Unterschied zwischen einem wohlgeformten und einem gueltigen XML-Dokument']","XSD (XML Schema Definition) bietet mehrere Vorteile gegenueber DTDs: Es ermoeglicht die Definition von Datentypen, unterstuetzt Namensraeume, ist in XML-Syntax geschrieben, was die Verarbeitung und das Verstaendnis erleichtert, und bietet erweiterte Validierungsmoeglichkeiten wie die Definition komplexer Typen und Einschraenkungen.",0.7728390539236236
"Werden Elemente, die nicht zum Namensraum von XSLT gehoeren, vom XSLT-Prozessor transformiert?"," Ja, Elemente, die nicht zum Namensraum von XSLT gehoeren, werden vom XSLT-Prozessor transformiert. Sie werden im Ausgabedokument als sie sind uebernommen, ohne dass ihnen etwas hinzugefuegt oder entfernt wird.","['auch, denn das Stylesheet verwendet ja XPath-Ausdruecke, um die Knoten im Baum des Quelldokumentes zu suchen. Anschließend beginnt der eigentliche Prozess der Transformation. Zuerst wird immer die Template-Regel fuer die Wurzel des XML-Baums verarbeitet. Dabei werden immer genauso viele Quelldaten abgegriffen, wie es die Anweisungen der Template-Regeln erfordern. Mit diesen Quelldaten und Elementen, welche nicht zum XSLT-Namensraum gehoeren,'
 'Inhaltsverzeichnis 1. Einleitung 2. XSL-Transformationen 3. XQuery 4. Anhang 5. Literatur 6. Loesungen der Selbsttestaufgaben'
 'Selbsttestaufgabe 3.8 Bestimmen Sie fuer alle Elemente und Attribute des folgenden XML-Dokuments, ob sie zu einem Namensraum gehoeren, und wenn ja, zu welchem. Die Elemente gehoeren alle zu einem Namensraum. Die Attribute von Elementen des ersten Buchs gehoeren zum Namensraum mit der URI http://www.kurs1873.de/buch, die Attribute von Elementen des zweiten Buchs gehoeren hingegen zu keinem Namensraum. Das Element katalog und das zugehoerige Kindelement titel gehoeren zum Namensraum mit der URI http://www.kurs1873.de/katalog. Alle anderen Elemente gehoeren zum Namensraum mit der URI http://www.kurs1873.de/buch. Dazu gehoeren weiterhin die Attribute von Elementen des ersten Buchs. Selbsttestaufgabe 3.9 Gegeben sei folgende DTD fuer ein Buch: à Kurstext'
 'Fuer Namensraumknoten werden alle Namensraum-Deklarationen automatisch in das Ausgabedokument eingefuegt. Die Regeln bewirken in einem angenommenen minimalen Stylesheet, dass nacheinander alle Elemente betrachtet werden und dass bei jedem betrachteten Element der Inhalt ausgegeben wird. Grundlegende XSLT-Templates XSLT ist sehr umfangreich. Es gibt sogenannte Top-Level-Elemente als direkte Kinder des Wurzelelementes und zusaetzlich Anweisungselemente, die ueberall in einem Template auftreten koennen. Darueber hinaus koennen durch die Nutzung von XPath und durch XSLT- Prozessor-spezifische APIs beliebig komplexe Transformationen realisiert werden. Die vorliegende Kurseinheit soll sich im Folgenden auf die Darstellung der Grundprinzipien'
 'ausgegeben werden.       Frage  2    Fuellen  Sie die Luecke:  Eine XSL-Transformation  besteht  aus einer  Reihe  von einzelnen  Transformationsregeln, die Templates  genannt werden.       Frage  3    Wie heisst  das Wurzelelement  eines  Stylesheets?     • xml:stylesheet   • xsl:stylesheet   • xsl:transform   • xml: rootxsl   • xsl:transnorm     Frage  4    Bei XSLT werden verschiedene Arten von Knoten eines XM L-Dokuments unterschieden .  Nennen Sie diese :    • Wurzelknoten   • Elementknoten   • Attributknoten   • Textknoten   • Kommentarknoten   • Steuer anweisungsknoten   • Namensraumknote n']",Nein.,
Wie kann man eine Argumentation mithilfe von RDF formulieren?," Um eine Argumentation mit Hilfe von RDF zu formulieren, koennen Sie die einzelnen Teile des Arguments als RDF-Ressourcen darstellen und die Beziehungen zwischen diesen Ressourcen durch Aussagen (Triples) beschreiben. Hierbei kann die Definition eines Arguments im Argument Interchange Format (AIF) verwendet werden, bei der alle Teile des Arguments als RDF-Ressourcen dargestellt und mit Informationsknoten (I-Knoten) und Schemaknoten (S-Knoten) ergaenzt werden. Dabei enthaelt das Argument eine oder mehrere Praemissen und eine Schlussfolgerung, die durch Inferenz aus den Praemissen abgeleitet wird.","['<s:StatementOfSherlock> . <s:StatementOfSherlock> <http://www.w3.org/1999/02/22-rdf-syntax-ns#a> <rdf:Statement> . <s:StatementOfSherlock> <http://www.w3.org/1999/02/22-rdf-syntaxns# subject> <s:Gardener> . <s:StatementOfSherlock> <http://www.w3.org/1999/02/22-rdf-syntaxns# predicate> <s:hasKilled> . <s:StatementOfSherlock> <http://www.w3.org/1999/02/22-rdf-syntaxns# object> <s:Butler> . Das Prinzip der Reifikation ermoeglicht es, in RDF Aussagen ueber Aussagen zu treffen. Im Beispiel ist die „innere“ Aussage, dass der Gaertner den Butler getoetet hat. Ergaenzt wird dies durch die zusaetzliche Aussage, dass Sherlock Holmes diesen Sachverhalt (lediglich) vermutet. 5.4: Woraus besteht ein Argument im Sinne des Argument Interchange Format (AIF)?'
 'Argumente Der folgende Abschnitt befasst sich mit den sogenannten RDF Argumenten, einer speziellen Form von Aussagen zur Repraesentation von Logik. Eine Argumentation ist Teil eines Dialogs, bei dem eine Partei eine andere Partei von einer Behauptung mittels Argumenten ueberzeugen will. [MM09] Argumente werden konstruiert, ausgetauscht und in Bezug auf andere Argumente und die Hauptbehauptung, auf die sie sich beziehen, bewertet. Es gibt viele verschiedene Definitionen von Argumenten, wobei oft eine gemeinsame Grundlage ist, dass ein Argument aus Praemissen und einer Schlussfolgerung besteht. Die Menge der Praemissen erlaubt die Ableitung der Schlussfolgerung durch Inferenz , daher enthaelt die weit verbreitete Definition eines Arguments einen zusaetzlichen'
 '<rdf:predicate  rdf:resource=""sportart:istEine""/>   <rdf:object  rdf:resource=""sparte:Ballsportart""/>   </rdf:Statement>   </rdf:RDF>           5.4 Welche  Aussagen  zu Argumenten  im Sinne  der AIF sind korrekt?           5.5 : RDF -Schema bietet ein Vokabular, um zu spezifizieren, welche semantischen  Merkmale zu welchen Objekten gehoeren und welche semantischen Werte die  Merkmale der  Objekte  annehmen  koennen.  Auch  die Beziehungen  zwischen  Objekten  und deren Merkmalen werden besch rieben.'
 'Inhaltsverzeichnis 1. Einleitung 2. Motivation und Einfuehrung 3. Einfuehrung zu Semantik und RDF 4. RDF Schemata 5. Erzeugung von Ontologien mittels OWL 6. Metadaten 7. Anhang 8. Literatur 9. Loesungen der Selbsttestaufgaben'
 'Inferenzknoten fuer die Inferenz von den Praemissen zur Schlussfolgerung. Diese Definition eines Arguments wird im Argument Interchange Format (AIF) verwendet, bei dem RDF und RDFS verwendet werden, um alle Argumentteile als RDF-Ressourcen darzustellen. AIF verwendet Informationsknoten (I-Knoten) und Schemaknoten (S-Knoten), wobeiAbbildung 5.8: Reifikation Selbsttestaufgabe 5.3: Erlaeutern Sie das Prinzip der Reifikation anhand des folgenden N-Triples: N-Triple: <sh:SherlockHolmes> <s:supposes> <s:StatementOfSherlock> . <s:StatementOfSherlock> <http://www.w3.org/1999/02/22-rdf-syntax-ns#a> <rdf:Statement> . <s:StatementOfSherlock> <http://www.w3.org/1999/02/22-rdf-syntaxns# subject> <s:Gardener> . <s:StatementOfSherlock> <http://www.w3.org/1999/02/22-rdf-syntaxns# predicate> <s:hasKilled> .']","Eine Argumentation kann in RDF formuliert werden, indem man Praemissen und Schlussfolgerungen als RDF-Ressourcen darstellt. Dabei werden Informationsknoten (I-Knoten) fuer aussagenbezogene Informationen und Schemaknoten (S-Knoten) fuer die Anwendung von Schemata verwendet. Dieses Format wird im Argument Interchange Format (AIF) genutzt, um logische Argumente und ihre Beziehungen zu repraesentieren.",0.7440797960095056
Was sind die wichtigsten Unterschiede zwischen den verschiedenen OWL-Versionen?," Die drei Versionen von OWL (Web Ontology Language) haben unterschiedliche Ausdrucksstaerken.  1. OWL Lite: Unterstuetzt einfache Restriktionen und die Bildung von Klassenhierarchien fuer die Darstellung einfacher Taxonomien. Es ist am wenigsten ausdrucksstark, aber einfach um Werkzeuge zu entwickeln. 2. OWL DL (Description Logic): Bietet eine erweiterte Ausdrucksstaerke und genuegt den Anforderungen der Description Logics, die die formelle Basis von OWL begruenden. Aktuelle Softwarewerkzeuge unterstuetzen OWL DL fast vollstaendig. 3. Die ausdrueckliche Version von OWL: Bietet die groeßte Ausdrucksstaerke und unterstuetzt die Beschreibung komplexerer Ontologien, aber es werden nur beschraenkte Werkzeuge zur Verarbeitung von OWL entwickelt.  Die Unterschiede zwischen den Versionen liegen in der Art und Weise, wie sie Komplexitaet, Ausdrucksstaerke und Verarbeitungszeit beeinflussen. Die Entscheidbarkeit von OWL DL bedeutet, dass die Verarbeitung in endlicher Zeit ausgefuehrt wird.","['Inhaltsverzeichnis 1. Einleitung 2. Motivation und Einfuehrung 3. Einfuehrung zu Semantik und RDF 4. RDF Schemata 5. Erzeugung von Ontologien mittels OWL 6. Metadaten 7. Anhang 8. Literatur 9. Loesungen der Selbsttestaufgaben'
 'Varianten mit unterschiedlichen Ausdrucksstaerken: •    OWL Lite: ist OWL in seiner einfachsten Auspraegung. Hier werden einfache Restriktionen und die Bildung von Klassenhierarchien unterstuetzt. Es dient der Darstellung einfacher Taxonomien. Fuer OWL Lite koennen einfache Werkzeuge entwickelt werden. Allerdings ist es damit auch am wenigsten ausdrucksstark. •    OWL DL: beinhaltet OWL Lite und bietet eine erweiterte Ausdrucksstaerke. Es genuegt den Anforderungen der Decription Logics, welche die Logik behandelt, die die formelle Basis von OWL begruendet. Aktuelle Softwarewerkzeuge unterstuetzen OWL DL fast vollstaendig. Diese Auspraegung von OWL ist entscheidbar, sprich die Verarbeitung wird in endlicher Zeit ausgefuehrt.'
 ""URIreference ')'                                          | 'Annotation(' annotationPropertyID                                             dataLiteral ')'                                          | 'Annotation(' annotationPropertyID                                             individual ')' | axiom                                          | fact Beispiel fuer Annotationen: Ontology(x:meineKleineOntology                                          Annotation(x:updated 2002-11-25^^xsd:date)                                                     Annotation(owl:incompatibleWith                                          x:meineAndereOntology) . . . )Selbsttestaufgabe 5.6: Wofuer steht die Abkuerzung OWL und worin besteht die generelle Anwendung?""
 'Informationsanbieter dieselben Begriffe nutzen, benoetigt man ein oder mehrere standardisierte Vokabulare. Klassen, derer man sich in der OWL bedient, koennen zwar in anderen Ontologien bearbeitet bzw. erweitert werden, es koennen aber keine Fakten aus der Klasse entfernt werden. OWL im Detail Die vom W3C veroeffentlichte Version der OWL-Spezifikation umfasst drei verschiedene Varianten mit unterschiedlichen Ausdrucksstaerken: •    OWL Lite: ist OWL in seiner einfachsten Auspraegung. Hier werden einfache Restriktionen und die Bildung von Klassenhierarchien unterstuetzt. Es dient der Darstellung einfacher Taxonomien. Fuer OWL Lite koennen einfache Werkzeuge entwickelt werden. Allerdings ist es damit auch am wenigsten ausdrucksstark.'
 'Inhaltsverzeichnis 1. Einleitung 2. XSL-Transformationen 3. XQuery 4. Anhang 5. Literatur 6. Loesungen der Selbsttestaufgaben']","Die verschiedenen OWL-Versionen (OWL Lite, OWL DL, OWL Full) unterscheiden sich hauptsaechlich in ihrer Ausdruckskraft und Komplexitaet. OWL Lite ist die einfachste Version und fuer grundlegende Klassifikationen geeignet. OWL DL bietet eine hoehere Ausdruckskraft und bleibt dabei berechenbar. OWL Full ist die umfangreichste Version, die volle RDF-Kompatibilitaet bietet, aber die Berechenbarkeit nicht garantiert. OWL 2 erweitert diese Versionen um zusaetzliche Features wie erweiterte Datentypen und verbesserte Werkzeuge fuer die Modellierung komplexer Klassen und Eigenschaften.",0.7819254699960105
